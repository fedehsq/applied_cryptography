#include <openssl/evp.h>
#include <openssl/pem.h>
#include <openssl/rand.h>
#include <openssl/err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
typedef unsigned char* bytes;
typedef unsigned char byte;
using namespace std; 

const int PADDING = 16;

int main() {

    /* open plaintext file */
    FILE* fp_input = fopen("input.txt", "r");
    if (!fp_input) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    /* move fp from 0 to end of file */
    if (fseek(fp_input, 0, SEEK_END) == -1) {
        fclose(fp_input);
        perror("fseek");
        exit(EXIT_FAILURE);
    }

    /* get file len */
    int plaintext_len = ftell(fp_input);
    if (plaintext_len == -1) {
        fclose(fp_input);
        perror("ftell");
        exit(EXIT_FAILURE);
    }

    /* allocate space for plaintext */
    char* plaintext = (char*) calloc(plaintext_len + 1, sizeof(char));
    if (!plaintext) {
        fclose(fp_input);
        perror("calloc");
        exit(EXIT_FAILURE);
    }

    /* restore file pointer to the beginning of file */
    rewind(fp_input);

    /* save into buffer all bytes of file */
    int read = fread(plaintext, 1, plaintext_len, fp_input);
    if (!read){
        fclose(fp_input);
        free(plaintext);
        perror("fread");
        exit(EXIT_FAILURE);
    }

    /* close input file */
    fclose(fp_input);

    /* open public key file */
    FILE* fp_public_key = fopen("public_key.pem", "r");
    if (!fp_public_key) {
        perror("fopen");
        free(plaintext);
        exit(EXIT_FAILURE);
    }

    /* read public key from file */
    EVP_PKEY* public_key = PEM_read_PUBKEY(fp_public_key, NULL, NULL, NULL);
    if (!public_key) {
        cout << "reading public key";
        ERR_print_errors_fp(stderr);
        fclose(fp_public_key);
        free(plaintext);
        exit(EXIT_FAILURE);
    }

    /* close public key file */
    fclose(fp_public_key);

    /* iv len depends of cypher type */
    int iv_len = EVP_CIPHER_iv_length(EVP_aes_128_cbc());

    /* allocate buffer where to store iv generated by seal_init */
    bytes iv = (bytes) calloc(iv_len + 1, sizeof(byte));
    if (!iv) {
        EVP_PKEY_free(public_key);
        free(plaintext);
        perror("calloc");
        exit(EXIT_FAILURE);
    }

    /* encrypted_symmetric_key_size depends of public key size */
    int encrypted_symmetric_key_size = EVP_PKEY_size(public_key);

    /* allocate buffer where to store encrypted_symmetric_key
    generated by seal_init */
    bytes encrypted_symmetric_key = 
    (bytes) calloc(encrypted_symmetric_key_size + 1, sizeof(byte));
    if (!encrypted_symmetric_key) {
        EVP_PKEY_free(public_key);
        free(iv);
        free(plaintext);
        perror("calloc");
        exit(EXIT_FAILURE);
    }

    /* allocate buffer where to store cyphertext
    generated by seal_update */
    bytes ciphertext = (bytes) calloc(plaintext_len + PADDING + 1, sizeof(byte));
    if (!ciphertext) {
        EVP_PKEY_free(public_key);
        free(iv);
        free(plaintext);
        free(encrypted_symmetric_key);
        perror("calloc");
        exit(EXIT_FAILURE);
    }

    /* allocate the cipher context */
    EVP_CIPHER_CTX* context = EVP_CIPHER_CTX_new();
    if (!context) {
        EVP_PKEY_free(public_key);
        free(iv);
        free(plaintext);
        free(encrypted_symmetric_key);
        free(ciphertext);
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }

    /* real len of encrypted_symmetric_key generated by seal init */
    int encrypted_symmetric_key_len;

    /* generate symmetric key and iv using public key */
    int ret = EVP_SealInit(context, EVP_aes_128_cbc(), 
     &encrypted_symmetric_key, &encrypted_symmetric_key_len, iv,
     &public_key, 1); 

    if (!ret){
        EVP_CIPHER_CTX_free(context);
        EVP_PKEY_free(public_key);
        free(iv);
        free(plaintext);
        free(encrypted_symmetric_key);
        free(ciphertext);
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }
    
    /* real bytes written from seal update */
    int written;
    /* len of ciphertext given from seal update */
    int ciphertext_len;

    /* encrypt plaintext */
    ret = EVP_SealUpdate(context, ciphertext, &written, 
     (bytes)plaintext, strlen(plaintext));
    if (!ret){
        EVP_CIPHER_CTX_free(context);
        EVP_PKEY_free(public_key);
        free(iv);
        free(plaintext);
        free(encrypted_symmetric_key);
        free(ciphertext);
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }
    ciphertext_len = written;

    /* finalize encryption, add padding */
    ret = EVP_SealFinal(context, &ciphertext[written], &written);
    if (!ret){
        EVP_PKEY_free(public_key);
        free(iv);
        free(plaintext);
        free(encrypted_symmetric_key);
        free(ciphertext);
        ERR_print_errors_fp(stderr);
        exit(EXIT_FAILURE);
    }
    /* update len */
    ciphertext_len += written;

    /* clean public key */
    EVP_PKEY_free(public_key);

    /* clean cipher context */
    EVP_CIPHER_CTX_free(context);

    /* not needed anymore */
    free(plaintext);

    /* open output file */
    FILE* fp_encrypted = fopen("encr.txt", "wb");
    if (!fp_encrypted){
        free(iv);
        free(encrypted_symmetric_key);
        free(ciphertext);
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    /* write encrypted symmetric key to file */
    written = fwrite(encrypted_symmetric_key, 1,
     encrypted_symmetric_key_len, fp_encrypted);
    if (!written) {
        free(iv);
        free(encrypted_symmetric_key);
        free(ciphertext);
        perror("fwrite");
        exit(EXIT_FAILURE);
    }

    /* destroy encrypted key */
    free(encrypted_symmetric_key);

    /* write iv to file */
    written = fwrite(iv, 1, iv_len, fp_encrypted);
    if (!written) {
        free(iv);
        free(ciphertext);
        perror("fwrite");
        exit(EXIT_FAILURE);
    }

    /* destroy iv */
    free(iv);

    /* write ciphertext to file */
    written = fwrite(ciphertext, 1, ciphertext_len, fp_encrypted);
    if (!written) {
        free(ciphertext);
        perror("fwrite");
        exit(EXIT_FAILURE);
    }

    /* destroy ciphertext */
    free(ciphertext);
}